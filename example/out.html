
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="src/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/java.min.js"></script>
    <script>hljs.highlightAll();</script>
    <style>
    body {
        background: #f8f9fa;
        padding: 0 24px;
        margin: 0;
        color: black;
        display: flex;
        justify-content: flex-start;
        flex-direction: column;
        align-items: flex-start;
    }
    table, th, td {
        border: 1px solid black;
    }
    .header {
        width: 100%;
        text-align: center;
        margin: 0 auto;
    }
    .table-container {
        width: 80%;
        margin: 0 auto;
    }
    table {
        width: 100%;
        table-layout: fixed; /* Ensures equal column distribution */
        border-collapse: collapse;
    }
    th, td {
        width: 50%; /* Split columns equally */
        vertical-align: top;
        padding: 10px;
    }
    pre {
        margin: 0;
        white-space: pre-wrap; /* Preserve formatting but allow wrapping */
    }
    .wrap {
        overflow-wrap: break-word; /* Break long words */
        word-break: break-all; /* Ensure breaks happen if needed */
        white-space: pre-wrap;      /* Respect pre-formatted wrapping */
    }
    .large-code {
        font-size: 1.2em;
        overflow-wrap: break-word;  /* Break long words */
        word-break: break-all;      /* Ensure breaks happen if needed */
        white-space: pre-wrap;      /* Respect pre-formatted wrapping */
    }
    .header-code {
        width: 40%;
        overflow-x: auto;
        margin: 0 auto;
        padding-bottom: 15px;
    }
    </style>
  </head>
<div class="header">
<h1>Originating Test:</h1>
<h2>io.lettuce.core.metrics.DefaultCommandLatencyCollectorUnitTests#verifyCummulativeMetrics</h2>
<h1>Algorithm:</h1>
<h2>shb</h2>
<h1>Field Declaration:</h1>
<div class="header-code">
<pre><code class="large-code language-java">protected final long intervalEndTimes[];</code></pre>
</div>
</div>

  <body>
    <div class="table-container">
    <table>
  <thead>
    <tr>
      <th><h2>Stack Trace 1</h2></th>
      <th><h2>Stack Trace 2</h2></th>
    </tr>
  </thead>
  <tbody>
<tr>
<td><strong>Depth:</strong> 14</td>
<td><strong>Depth:</strong> 8</td>
</tr>
<tr>
<td>
<strong><code class="large-code">org.LatencyUtils.MovingAverageIntervalEstimator#recordIntervalAndReturnWindowPosition:50</code></strong>
<pre><code class="language-java large-code">
/**
 * A moving average interval estimator. Estimates intervals by averaging the interval values recorded in a
 * moving window. Will only provide average estimate once enough intervals have been collected to fill the
 * window, and will return an impossibly long interval estimate until then.
 */
public class MovingAverageIntervalEstimator extends IntervalEstimator {
int recordIntervalAndReturnWindowPosition(long when) {
    // ...
        intervalEndTimes[positionToSwap] = when;
</code></pre>
</td><td>
<strong><code class="large-code">org.LatencyUtils.TimeCappedMovingAverageIntervalEstimator#determineNumberOfWindowPositionsOutsideOfTimeCap:244</code></strong>
<pre><code class="language-java large-code">
public class TimeCappedMovingAverageIntervalEstimator extends MovingAverageIntervalEstimator {
private int determineNumberOfWindowPositionsOutsideOfTimeCap(long when) {
    // ...
        if (intervalEndTimes[currentPosition] &gt;= timeCapStartTime) {
</code></pre>
</td></tr>
<tr>
<td>
<strong><code class="large-code">org.LatencyUtils.TimeCappedMovingAverageIntervalEstimator#recordInterval:83</code></strong>
<pre><code class="language-java large-code">
public class TimeCappedMovingAverageIntervalEstimator extends MovingAverageIntervalEstimator {
@Override
    public void recordInterval(long when) {
    // ...
        super.recordIntervalAndReturnWindowPosition(when);
</code></pre>
</td><td>
<strong><code class="large-code">org.LatencyUtils.TimeCappedMovingAverageIntervalEstimator#determineEarliestQualifyingTimeInWindow:228</code></strong>
<pre><code class="language-java large-code">
public class TimeCappedMovingAverageIntervalEstimator extends MovingAverageIntervalEstimator {
private long determineEarliestQualifyingTimeInWindow(final long when) {
    // ...
        int numberOfWindowPositionsOutsideOfTimeCap = determineNumberOfWindowPositionsOutsideOfTimeCap(when);
</code></pre>
</td></tr>
<tr>
<td>
<strong><code class="large-code">org.LatencyUtils.LatencyStats#trackRecordingInterval:417</code></strong>
<pre><code class="language-java large-code">
/**
 * LatencyStats objects are used to track and report on the behavior of latencies across measurements.
 * recorded into a a given LatencyStats instance. Latencies are recorded using
 * {@link #recordLatency}, which provides a thread safe, wait free, and lossless recording method.
 * The accumulated behavior across the recorded latencies in a given LatencyStats instance can be
 * examined in detail using interval and accumulated HdrHistogram histograms
 * (see {@link org.HdrHistogram.Histogram}).
 * &lt;p&gt;
 * LatencyStats instances maintain internal histogram data that track all recoded latencies. Interval
 * histogram data can be sampled with the {@link #getIntervalHistogram},
 * {@link #getIntervalHistogramInto}, or {@link #addIntervalHistogramTo} calls.
 * &lt;p&gt;
 * Recorded latencies are auto-corrected for experienced pauses by leveraging pause detectors and
 * moving window average interval estimators, compensating for coordinated omission. While typical
 * histogram use deals with corrected data, LatencyStats instances do keep track of the raw,
 * uncorrected records, which can be accessed via the {@link #getLatestUncorrectedIntervalHistogram}
 * and {@link #getLatestUncorrectedIntervalHistogramInto} calls.
 * &lt;p&gt;
 * LatencyStats objects can be instantiated either directly via the provided constructors, or by
 * using the fluent API builder supported by {@link org.LatencyUtils.LatencyStats.Builder}.
 *
 * &lt;h3&gt;Correction Technique&lt;/h3&gt;
 * In addition to tracking the raw latency recordings provided via {@link #recordLatency}, each
 * LatencyStats instance maintains an internal interval estimator that tracks the expected
 * interval between latency recordings. Whenever a stall in measurement is detected by a given
 * pause detector, each LatencyStats instances that uses that pause detector will be notified,
 * and will generate correcting latency entries (that are separately tracked internally).
 * Correcting latency entries are computed to &quot;fill in&quot; detected measurement pauses by projecting
 * the observed recording rate into the pause gap, and creating a linearly diminishing latency
 * measurement for each missed recording interval.
 * &lt;p&gt;
 * Pause detection and interval estimation are both configurable, and each LatencyStats instance
 * can operate with potentially independent pause detector and interval estimator settings.
 * &lt;p&gt;
 * A configurable default pause detector is (by default) shared between LatencyStats instances
 * that are not provided with a specific pause detector at instantiation. If the default pause
 * detector is not explicitly set, it will itself default to creating (and starting) a single
 * instance of {@link org.LatencyUtils.SimplePauseDetector}, which uses consensus observation
 * of a pause across multiple observing threads as a detection technique.
 * &lt;p&gt;
 * Custom pause detectors can be provided (by subclassing {@link org.LatencyUtils.PauseDetector}).
 * E.g. a pause detector that pauses GC log output rather than directly measuring observations
 * can be constructed. A custom pause detector can be especially useful in situations where a
 * stall in the operation and latency measurement of an application&#x27;s is known and detectable
 * by the application level, but would not be detectable as a process-wide stall in execution
 * (which {@link org.LatencyUtils.SimplePauseDetector} is built to detect).
 * &lt;p&gt;
 * Interval estimation is done by using a time-capped moving window average estimator, with
 * the expected interval computed to be the average of measurement intervals within the window
 * (with the window being capped by both count and time). See
 * {@link TimeCappedMovingAverageIntervalEstimator} for more details. The estimator window
 * length and time cap can both be configured when instantiating a LatencyStats object
 * (defaults are 1024, and 10 seconds).
 *
 */
public class LatencyStats {
private void trackRecordingInterval() {
    // ...
        intervalEstimator.recordInterval(now);
</code></pre>
</td><td>
<strong><code class="large-code">org.LatencyUtils.TimeCappedMovingAverageIntervalEstimator#eliminateStalePauses:197</code></strong>
<pre><code class="language-java large-code">
public class TimeCappedMovingAverageIntervalEstimator extends MovingAverageIntervalEstimator {
private void eliminateStalePauses(final long when) {
    // ...
        long newEarliestQualifyingTimeInWindow = determineEarliestQualifyingTimeInWindow(when);
</code></pre>
</td></tr>
<tr>
<td>
<strong><code class="large-code">org.LatencyUtils.LatencyStats#recordLatency:200</code></strong>
<pre><code class="language-java large-code">
/**
 * LatencyStats objects are used to track and report on the behavior of latencies across measurements.
 * recorded into a a given LatencyStats instance. Latencies are recorded using
 * {@link #recordLatency}, which provides a thread safe, wait free, and lossless recording method.
 * The accumulated behavior across the recorded latencies in a given LatencyStats instance can be
 * examined in detail using interval and accumulated HdrHistogram histograms
 * (see {@link org.HdrHistogram.Histogram}).
 * &lt;p&gt;
 * LatencyStats instances maintain internal histogram data that track all recoded latencies. Interval
 * histogram data can be sampled with the {@link #getIntervalHistogram},
 * {@link #getIntervalHistogramInto}, or {@link #addIntervalHistogramTo} calls.
 * &lt;p&gt;
 * Recorded latencies are auto-corrected for experienced pauses by leveraging pause detectors and
 * moving window average interval estimators, compensating for coordinated omission. While typical
 * histogram use deals with corrected data, LatencyStats instances do keep track of the raw,
 * uncorrected records, which can be accessed via the {@link #getLatestUncorrectedIntervalHistogram}
 * and {@link #getLatestUncorrectedIntervalHistogramInto} calls.
 * &lt;p&gt;
 * LatencyStats objects can be instantiated either directly via the provided constructors, or by
 * using the fluent API builder supported by {@link org.LatencyUtils.LatencyStats.Builder}.
 *
 * &lt;h3&gt;Correction Technique&lt;/h3&gt;
 * In addition to tracking the raw latency recordings provided via {@link #recordLatency}, each
 * LatencyStats instance maintains an internal interval estimator that tracks the expected
 * interval between latency recordings. Whenever a stall in measurement is detected by a given
 * pause detector, each LatencyStats instances that uses that pause detector will be notified,
 * and will generate correcting latency entries (that are separately tracked internally).
 * Correcting latency entries are computed to &quot;fill in&quot; detected measurement pauses by projecting
 * the observed recording rate into the pause gap, and creating a linearly diminishing latency
 * measurement for each missed recording interval.
 * &lt;p&gt;
 * Pause detection and interval estimation are both configurable, and each LatencyStats instance
 * can operate with potentially independent pause detector and interval estimator settings.
 * &lt;p&gt;
 * A configurable default pause detector is (by default) shared between LatencyStats instances
 * that are not provided with a specific pause detector at instantiation. If the default pause
 * detector is not explicitly set, it will itself default to creating (and starting) a single
 * instance of {@link org.LatencyUtils.SimplePauseDetector}, which uses consensus observation
 * of a pause across multiple observing threads as a detection technique.
 * &lt;p&gt;
 * Custom pause detectors can be provided (by subclassing {@link org.LatencyUtils.PauseDetector}).
 * E.g. a pause detector that pauses GC log output rather than directly measuring observations
 * can be constructed. A custom pause detector can be especially useful in situations where a
 * stall in the operation and latency measurement of an application&#x27;s is known and detectable
 * by the application level, but would not be detectable as a process-wide stall in execution
 * (which {@link org.LatencyUtils.SimplePauseDetector} is built to detect).
 * &lt;p&gt;
 * Interval estimation is done by using a time-capped moving window average estimator, with
 * the expected interval computed to be the average of measurement intervals within the window
 * (with the window being capped by both count and time). See
 * {@link TimeCappedMovingAverageIntervalEstimator} for more details. The estimator window
 * length and time cap can both be configured when instantiating a LatencyStats object
 * (defaults are 1024, and 10 seconds).
 *
 */
public class LatencyStats {
    /**
     * Record a latency value in the LatencyStats object
     * @param latency latency value (in nanoseconds) to record
     */
public void recordLatency(long latency) {
    // ...
            trackRecordingInterval();
</code></pre>
</td><td>
<strong><code class="large-code">org.LatencyUtils.TimeCappedMovingAverageIntervalEstimator#getEstimatedInterval:90</code></strong>
<pre><code class="language-java large-code">
public class TimeCappedMovingAverageIntervalEstimator extends MovingAverageIntervalEstimator {
@Override
    public synchronized long getEstimatedInterval(final long when) {
    // ...
        eliminateStalePauses(when);
</code></pre>
</td></tr>
<tr>
<td><strong>Error</strong><br><code class="large-code">io.lettuce.core.metrics.DefaultCommandLatencyCollector.recordCommandLatency(DefaultCommandLatencyCollector.java:132))</code><br>No file found ending with 'io/lettuce/core/metrics/DefaultCommandLatencyCollector.java'</td><td>
<strong><code class="large-code">org.LatencyUtils.LatencyStats#recordDetectedPause:402</code></strong>
<pre><code class="language-java large-code">
/**
 * LatencyStats objects are used to track and report on the behavior of latencies across measurements.
 * recorded into a a given LatencyStats instance. Latencies are recorded using
 * {@link #recordLatency}, which provides a thread safe, wait free, and lossless recording method.
 * The accumulated behavior across the recorded latencies in a given LatencyStats instance can be
 * examined in detail using interval and accumulated HdrHistogram histograms
 * (see {@link org.HdrHistogram.Histogram}).
 * &lt;p&gt;
 * LatencyStats instances maintain internal histogram data that track all recoded latencies. Interval
 * histogram data can be sampled with the {@link #getIntervalHistogram},
 * {@link #getIntervalHistogramInto}, or {@link #addIntervalHistogramTo} calls.
 * &lt;p&gt;
 * Recorded latencies are auto-corrected for experienced pauses by leveraging pause detectors and
 * moving window average interval estimators, compensating for coordinated omission. While typical
 * histogram use deals with corrected data, LatencyStats instances do keep track of the raw,
 * uncorrected records, which can be accessed via the {@link #getLatestUncorrectedIntervalHistogram}
 * and {@link #getLatestUncorrectedIntervalHistogramInto} calls.
 * &lt;p&gt;
 * LatencyStats objects can be instantiated either directly via the provided constructors, or by
 * using the fluent API builder supported by {@link org.LatencyUtils.LatencyStats.Builder}.
 *
 * &lt;h3&gt;Correction Technique&lt;/h3&gt;
 * In addition to tracking the raw latency recordings provided via {@link #recordLatency}, each
 * LatencyStats instance maintains an internal interval estimator that tracks the expected
 * interval between latency recordings. Whenever a stall in measurement is detected by a given
 * pause detector, each LatencyStats instances that uses that pause detector will be notified,
 * and will generate correcting latency entries (that are separately tracked internally).
 * Correcting latency entries are computed to &quot;fill in&quot; detected measurement pauses by projecting
 * the observed recording rate into the pause gap, and creating a linearly diminishing latency
 * measurement for each missed recording interval.
 * &lt;p&gt;
 * Pause detection and interval estimation are both configurable, and each LatencyStats instance
 * can operate with potentially independent pause detector and interval estimator settings.
 * &lt;p&gt;
 * A configurable default pause detector is (by default) shared between LatencyStats instances
 * that are not provided with a specific pause detector at instantiation. If the default pause
 * detector is not explicitly set, it will itself default to creating (and starting) a single
 * instance of {@link org.LatencyUtils.SimplePauseDetector}, which uses consensus observation
 * of a pause across multiple observing threads as a detection technique.
 * &lt;p&gt;
 * Custom pause detectors can be provided (by subclassing {@link org.LatencyUtils.PauseDetector}).
 * E.g. a pause detector that pauses GC log output rather than directly measuring observations
 * can be constructed. A custom pause detector can be especially useful in situations where a
 * stall in the operation and latency measurement of an application&#x27;s is known and detectable
 * by the application level, but would not be detectable as a process-wide stall in execution
 * (which {@link org.LatencyUtils.SimplePauseDetector} is built to detect).
 * &lt;p&gt;
 * Interval estimation is done by using a time-capped moving window average estimator, with
 * the expected interval computed to be the average of measurement intervals within the window
 * (with the window being capped by both count and time). See
 * {@link TimeCappedMovingAverageIntervalEstimator} for more details. The estimator window
 * length and time cap can both be configured when instantiating a LatencyStats object
 * (defaults are 1024, and 10 seconds).
 *
 */
public class LatencyStats {
private synchronized void recordDetectedPause(long pauseLength, long pauseEndTime) {
    // ...
            long estimatedInterval = intervalEstimator.getEstimatedInterval(pauseEndTime);
</code></pre>
</td></tr>
<tr>
<td><strong>Error</strong><br><code class="large-code">io.lettuce.core.metrics.DefaultCommandLatencyCollectorUnitTests.setupData(DefaultCommandLatencyCollectorUnitTests.java:150))</code><br>No file found ending with 'io/lettuce/core/metrics/DefaultCommandLatencyCollectorUnitTests.java'</td><td>
<strong><code class="large-code">org.LatencyUtils.LatencyStats#access$600:69</code></strong>
<pre><code class="language-java large-code">
/**
 * LatencyStats objects are used to track and report on the behavior of latencies across measurements.
 * recorded into a a given LatencyStats instance. Latencies are recorded using
 * {@link #recordLatency}, which provides a thread safe, wait free, and lossless recording method.
 * The accumulated behavior across the recorded latencies in a given LatencyStats instance can be
 * examined in detail using interval and accumulated HdrHistogram histograms
 * (see {@link org.HdrHistogram.Histogram}).
 * &lt;p&gt;
 * LatencyStats instances maintain internal histogram data that track all recoded latencies. Interval
 * histogram data can be sampled with the {@link #getIntervalHistogram},
 * {@link #getIntervalHistogramInto}, or {@link #addIntervalHistogramTo} calls.
 * &lt;p&gt;
 * Recorded latencies are auto-corrected for experienced pauses by leveraging pause detectors and
 * moving window average interval estimators, compensating for coordinated omission. While typical
 * histogram use deals with corrected data, LatencyStats instances do keep track of the raw,
 * uncorrected records, which can be accessed via the {@link #getLatestUncorrectedIntervalHistogram}
 * and {@link #getLatestUncorrectedIntervalHistogramInto} calls.
 * &lt;p&gt;
 * LatencyStats objects can be instantiated either directly via the provided constructors, or by
 * using the fluent API builder supported by {@link org.LatencyUtils.LatencyStats.Builder}.
 *
 * &lt;h3&gt;Correction Technique&lt;/h3&gt;
 * In addition to tracking the raw latency recordings provided via {@link #recordLatency}, each
 * LatencyStats instance maintains an internal interval estimator that tracks the expected
 * interval between latency recordings. Whenever a stall in measurement is detected by a given
 * pause detector, each LatencyStats instances that uses that pause detector will be notified,
 * and will generate correcting latency entries (that are separately tracked internally).
 * Correcting latency entries are computed to &quot;fill in&quot; detected measurement pauses by projecting
 * the observed recording rate into the pause gap, and creating a linearly diminishing latency
 * measurement for each missed recording interval.
 * &lt;p&gt;
 * Pause detection and interval estimation are both configurable, and each LatencyStats instance
 * can operate with potentially independent pause detector and interval estimator settings.
 * &lt;p&gt;
 * A configurable default pause detector is (by default) shared between LatencyStats instances
 * that are not provided with a specific pause detector at instantiation. If the default pause
 * detector is not explicitly set, it will itself default to creating (and starting) a single
 * instance of {@link org.LatencyUtils.SimplePauseDetector}, which uses consensus observation
 * of a pause across multiple observing threads as a detection technique.
 * &lt;p&gt;
 * Custom pause detectors can be provided (by subclassing {@link org.LatencyUtils.PauseDetector}).
 * E.g. a pause detector that pauses GC log output rather than directly measuring observations
 * can be constructed. A custom pause detector can be especially useful in situations where a
 * stall in the operation and latency measurement of an application&#x27;s is known and detectable
 * by the application level, but would not be detectable as a process-wide stall in execution
 * (which {@link org.LatencyUtils.SimplePauseDetector} is built to detect).
 * &lt;p&gt;
 * Interval estimation is done by using a time-capped moving window average estimator, with
 * the expected interval computed to be the average of measurement intervals within the window
 * (with the window being capped by both count and time). See
 * {@link TimeCappedMovingAverageIntervalEstimator} for more details. The estimator window
 * length and time cap can both be configured when instantiating a LatencyStats object
 * (defaults are 1024, and 10 seconds).
 *
 */
public class LatencyStats {
None
    // ...
public class LatencyStats {
</code></pre>
</td></tr>
<tr>
<td><strong>Error</strong><br><code class="large-code">io.lettuce.core.metrics.DefaultCommandLatencyCollectorUnitTests.verifyCummulativeMetrics(DefaultCommandLatencyCollectorUnitTests.java:139))</code><br>No file found ending with 'io/lettuce/core/metrics/DefaultCommandLatencyCollectorUnitTests.java'</td><td>
<strong><code class="large-code">org.LatencyUtils.LatencyStats$PauseTracker#handlePauseEvent:480</code></strong>
<pre><code class="language-java large-code">
    /**
     * PauseTracker is used to feed pause correction histograms whenever a pause is reported:
     */
private static class PauseTracker extends WeakReference&lt;LatencyStats&gt; implements PauseDetectorListener {
public void handlePauseEvent(final long pauseLength, final long pauseEndTime) {
    // ...
                latencyStats.recordDetectedPause(pauseLength, pauseEndTime);
</code></pre>
</td></tr>
<tr>
<td><strong>Error</strong><br><code class="large-code">sun.reflect.NativeMethodAccessorImpl.invoke0(Native)</code><br>Invalid file:line format in line: sun.reflect.NativeMethodAccessorImpl.invoke0(Native)</td><td>
<strong><code class="large-code">org.LatencyUtils.PauseDetector$PauseDetectorThread#run:107</code></strong>
<pre><code class="language-java large-code">
private class PauseDetectorThread extends Thread {
public void run() {
    // ...
                            listener.handlePauseEvent(
</code></pre>
</td></tr>
<tr>
<td><strong>Error</strong><br><code class="large-code">Method))</code><br>Invalid line format: Method))</td><td></td></tr>
<tr>
<td><strong>Error</strong><br><code class="large-code">sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62))</code><br>No file found ending with 'sun/reflect/NativeMethodAccessorImpl.java'</td><td></td></tr>
<tr>
<td><strong>Error</strong><br><code class="large-code">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43))</code><br>No file found ending with 'sun/reflect/DelegatingMethodAccessorImpl.java'</td><td></td></tr>
<tr>
<td><strong>Error</strong><br><code class="large-code">java.lang.reflect.Method.invoke(Method.java:498))</code><br>No file found ending with 'java/lang/reflect/Method.java'</td><td></td></tr>
<tr>
<td><strong>Error</strong><br><code class="large-code">java.util.ArrayList.forEach(ArrayList.java:1259))</code><br>No file found ending with 'java/util/ArrayList.java'</td><td></td></tr>
<tr>
<td><strong>Error</strong><br><code class="large-code">java.util.ArrayList.forEach(ArrayList.java:1259))</code><br>No file found ending with 'java/util/ArrayList.java'</td><td></td></tr>

  </tbody>
</table>
</div>

  </body>
</html>
